(()=>{"use strict";var e={115:(e,t,a)=>{var r;a.d(t,{a$:()=>s,j$:()=>r,uu:()=>o,zE:()=>n}),function(e){e.DISCOVERED="discovered",e.ACTIVE="active",e.PAUSED="paused",e.COOLDOWN="cooldown",e.ERROR="error",e.REMOVED="removed"}(r||(r={}));const s={clickInterval:2,maxTabs:2,globalPaused:!1,loggingEnabled:!0,refreshInterval:10};function o(e){return{...e,interval:e.clickInterval}}function n(e){return{clickInterval:e.interval||e.clickInterval||s.clickInterval,maxTabs:e.maxTabs,globalPaused:e.globalPaused,loggingEnabled:e.loggingEnabled,refreshInterval:e.refreshInterval}}},167:(e,t,a)=>{a.r(t),a.d(t,{addLogEntry:()=>u,clearLogs:()=>f,getGlobalPauseState:()=>d,getInterval:()=>l,getLogs:()=>h,getManagedTabs:()=>g,getSettings:()=>n,initializeStorage:()=>w,saveGlobalPauseState:()=>c,saveInterval:()=>i,saveManagedTabs:()=>m,saveSettings:()=>o});var r=a(115);const s={SETTINGS:"extension_settings",TABS:"managed_tabs",LOGS:"activity_logs"};async function o(e){try{console.log("💾 STORAGE SAVE - Input settings:",e);const t=await n();console.log("💾 STORAGE SAVE - Current settings from storage:",t);const a={...t,...e};console.log("💾 STORAGE SAVE - Merged settings:",a);const o=(0,r.uu)(a);console.log("💾 STORAGE SAVE - Converted to storage format:",o),await chrome.storage.sync.set({[s.SETTINGS]:o}),console.log("💾 STORAGE SAVE - Successfully saved to Chrome Storage");const i=await chrome.storage.sync.get(s.SETTINGS);console.log("💾 STORAGE SAVE - Verification read from Chrome Storage:",i)}catch(e){throw console.error("❌ STORAGE SAVE - Failed:",e),new Error(`Storage save failed: ${e}`)}}async function n(){try{console.log("📥 STORAGE GET - Reading from Chrome Storage...");const o=await chrome.storage.sync.get(s.SETTINGS);console.log("📥 STORAGE GET - Raw result from Chrome Storage:",o);const n=o[s.SETTINGS];console.log("📥 STORAGE GET - Extracted stored settings:",n);const i=(0,r.uu)(r.a$);console.log("📥 STORAGE GET - Defaults in legacy format:",i);const l={...i,...n};console.log("📥 STORAGE GET - Merged legacy settings:",l);const c=(0,r.zE)(l);console.log("📥 STORAGE GET - Converted to modern format:",c);const d={clickInterval:b((a=c).clickInterval)?a.clickInterval:r.a$.clickInterval,maxTabs:(t=a.maxTabs,"number"==typeof t&&t>=1&&t<=5?a.maxTabs:r.a$.maxTabs),globalPaused:"boolean"==typeof a.globalPaused?a.globalPaused:r.a$.globalPaused,loggingEnabled:"boolean"==typeof a.loggingEnabled?a.loggingEnabled:r.a$.loggingEnabled,refreshInterval:(e=a.refreshInterval,"number"==typeof e&&e>=1&&e<=600?a.refreshInterval:r.a$.refreshInterval)};return console.log("📥 STORAGE GET - Final validated settings:",d),d}catch(e){console.error("❌ STORAGE GET - Failed:",e);const t={...r.a$};return console.log("📥 STORAGE GET - Returning defaults due to error:",t),t}var e,t,a}async function i(e){if(!b(e))throw new Error(`Invalid interval: ${e}. Must be between 1 and 600 minutes.`);await o({clickInterval:e})}async function l(){return(await n()).clickInterval}async function c(e){await o({globalPaused:e})}async function d(){return(await n()).globalPaused}async function m(e){try{await chrome.storage.local.set({[s.TABS]:e}),console.log("Managed tabs saved:",e.length)}catch(e){throw console.error("Failed to save managed tabs:",e),new Error(`Failed to save tabs: ${e}`)}}async function g(){try{return(await chrome.storage.local.get(s.TABS))[s.TABS]||[]}catch(e){return console.error("Failed to get managed tabs:",e),[]}}async function u(e){try{const t=await h(),a=[{...e,timestamp:Date.now()},...t].slice(0,10);await chrome.storage.local.set({[s.LOGS]:a})}catch(e){console.error("Failed to add log entry:",e)}}async function h(){try{return(await chrome.storage.local.get(s.LOGS))[s.LOGS]||[]}catch(e){return console.error("Failed to get logs:",e),[]}}async function f(){try{await chrome.storage.local.set({[s.LOGS]:[]})}catch(e){throw console.error("Failed to clear logs:",e),new Error(`Failed to clear logs: ${e}`)}}function b(e){return"number"==typeof e&&e>=1&&e<=600}async function w(){try{const e=await n();console.log("Storage initialized with settings:",e)}catch(e){console.error("Failed to initialize storage:",e)}}},658:(e,t,a)=>{a.r(t),a.d(t,{findResumeTabs:()=>l,getManagedTab:()=>h,getManagedTabsSync:()=>u,getTabManagerStatus:()=>p,initializeTabManager:()=>i,onTabRemoved:()=>m,onTabUpdated:()=>d,removeTab:()=>g,updateTabList:()=>c,updateTabState:()=>f});var r=a(115),s=a(167);let o=[],n=!1;async function i(){if(!n)try{o=await(0,s.getManagedTabs)(),await async function(){const e=[];try{const t=await chrome.tabs.query({currentWindow:!1}),a=t.filter((e=>{if(!e.url||void 0===e.id)return!1;const t=!e.discarded&&"unloaded"!==e.status;return w(e.url)&&t}));e.push(...a.map((e=>e.id)).filter((e=>void 0!==e))),console.log(`🧹 Cleanup found ${e.length} valid resume tabs out of ${t.length} total tabs`)}catch(e){return void console.error("Failed to get current tabs for cleanup:",e)}const t=o.length,a=[];o=o.filter((t=>{const r=e.includes(t.tabId);return r||a.push(t),r})),o.length!==t&&(await(0,s.saveManagedTabs)(o),console.log(`🧹 Cleaned up ${t-o.length} invalid tabs:`),a.forEach((e=>{console.log(`  - Removed: ${e.title} (ID: ${e.tabId})`)})),await(0,s.addLogEntry)({level:"info",message:`Cleaned up ${a.length} invalid tabs during initialization`,data:{removedTabIds:a.map((e=>e.tabId))}}))}(),await c(),chrome.tabs.onUpdated.hasListener(d)&&chrome.tabs.onUpdated.removeListener(d),chrome.tabs.onRemoved.hasListener(m)&&chrome.tabs.onRemoved.removeListener(m),chrome.windows.onFocusChanged.hasListener(b)&&chrome.windows.onFocusChanged.removeListener(b),chrome.tabs.onUpdated.addListener(d),chrome.tabs.onRemoved.addListener(m),chrome.windows.onFocusChanged.addListener(b),console.log("Tab event listeners set up (including window focus tracking)"),n=!0,await(0,s.addLogEntry)({level:"info",message:`Tab manager initialized with ${o.length} tabs`}),console.log("Tab manager initialized successfully")}catch(e){console.error("Failed to initialize tab manager:",e),await(0,s.addLogEntry)({level:"error",message:`Failed to initialize tab manager: ${e}`})}}async function l(){try{console.log("🔍 АГРЕССИВНЫЙ ПОИСК ТАБОВ С РЕЗЮМЕ НАЧАТ...");let e=[];try{e=await chrome.tabs.query({}),console.log(`📋 Method 1 - Found ${e.length} total tabs (all windows)`)}catch(e){console.error("Method 1 failed:",e)}if(0===e.length)try{e=await chrome.tabs.query({currentWindow:!0}),console.log(`📋 Method 2 - Found ${e.length} total tabs (current window)`)}catch(e){console.error("Method 2 failed:",e)}if(0===e.length)try{const t=await chrome.windows.getAll({populate:!0});console.log(`📋 Method 3 - Found ${t.length} windows`),e=[];for(const a of t)a.tabs&&e.push(...a.tabs);console.log(`📋 Method 3 - Found ${e.length} total tabs from windows`)}catch(e){console.error("Method 3 failed:",e)}if(0===e.length)try{const t=await chrome.tabs.query({url:"*://*.hh.kz/*"}),a=await chrome.tabs.query({url:"*://*.hh.ru/*"});e=[...t,...a],console.log(`📋 Method 4 - Found ${e.length} HH tabs directly`)}catch(e){console.error("Method 4 failed:",e)}console.log("🔍 All tab URLs:"),e.forEach(((e,t)=>{console.log(`  ${t+1}. ${e.url} (ID: ${e.id}) - Status: ${e.status}, Discarded: ${e.discarded}`)}));const t=e.filter((e=>{if(!e.url||void 0===e.id)return console.log(`❌ Skipping tab with no URL or ID: ${e.title}`),!1;const t="unloaded"!==e.status&&!e.discarded,a=w(e.url);if(a){if(!t)return console.log(`⚠️ НАЙДЕН ТАБ С РЕЗЮМЕ НО НЕВАЛИДНОЕ СОСТОЯНИЕ: ${e.title} (${e.url}) - Status: ${e.status}, Discarded: ${e.discarded}`),console.log("🔄 ПРИНИМАЕМ ТАБ НЕСМОТРЯ НА СОСТОЯНИЕ"),!0;console.log(`✅ НАЙДЕН ВАЛИДНЫЙ ТАБ С РЕЗЮМЕ: ${e.title} (${e.url}) - Status: ${e.status}`)}else(e.url.includes("hh.kz")||e.url.includes("hh.ru"))&&console.log(`❌ HH tab but not resume: ${e.url}`);return a}));console.log(`🎯 НАЙДЕНО ${t.length} ТАБОВ С РЕЗЮМЕ HEADHUNTER`);const a=t.slice(0,5);if(a.length!==t.length&&console.log(`⚠️ Limited to ${a.length} tabs (max 5 allowed)`),0===a.length){console.log("❌ НЕ НАЙДЕНО НИ ОДНОГО ТАБА С РЕЗЮМЕ!"),console.log("🔍 ДИАГНОСТИКА:");const t=e.filter((e=>e.url&&(e.url.includes("hh.kz")||e.url.includes("hh.ru"))));console.log(`📋 Всего HH табов: ${t.length}`),t.forEach(((e,t)=>{const a=e.url||"";console.log(`  ${t+1}. ${e.title}`),console.log(`     URL: ${a}`),console.log(`     Содержит /resume/: ${a.includes("/resume/")}`),console.log(`     isResumeUrl result: ${w(a)}`)}))}return a}catch(e){return console.error("Failed to find resume tabs:",e),await(0,s.addLogEntry)({level:"error",message:`Failed to find resume tabs: ${e}`}),[]}}async function c(){try{const e=await l(),t=e.map((e=>e.id)).filter((e=>void 0!==e));o=o.filter((e=>t.includes(e.tabId)));for(const t of e){if(void 0===t.id||void 0===t.url)continue;const e=o.find((e=>e.tabId===t.id));if(e)e.url=t.url,e.title=t.title||e.title;else{const e={tabId:t.id,url:t.url,title:t.title||"Unknown Resume",state:r.j$.DISCOVERED,errorCount:0};o.push(e),await(0,s.addLogEntry)({level:"info",message:`New resume tab discovered: ${e.title}`,tabId:t.id})}}await(0,s.saveManagedTabs)(o),console.log(`Tab list updated: ${o.length} managed tabs`)}catch(e){console.error("Failed to update tab list:",e),await(0,s.addLogEntry)({level:"error",message:`Failed to update tab list: ${e}`})}}async function d(e,t,a){try{const r=o.find((t=>t.tabId===e));if(!r)return void(a.url&&w(a.url)&&await c());if(t.url){if(!w(t.url))return void await g(e);r.url=t.url,await(0,s.addLogEntry)({level:"info",message:`Tab URL updated: ${r.title}`,tabId:e})}t.title&&(r.title=t.title),await(0,s.saveManagedTabs)(o)}catch(t){console.error("Failed to handle tab update:",t),await(0,s.addLogEntry)({level:"error",message:`Failed to handle tab update: ${t}`,tabId:e})}}async function m(e){try{await g(e)}catch(t){console.error("Failed to handle tab removal:",t),await(0,s.addLogEntry)({level:"error",message:`Failed to handle tab removal: ${t}`,tabId:e})}}async function g(e){const t=o.findIndex((t=>t.tabId===e));if(-1!==t){const a=o[t];a&&(o.splice(t,1),await(0,s.saveManagedTabs)(o),await(0,s.addLogEntry)({level:"info",message:`Tab removed from management: ${a.title}`,tabId:e}),console.log(`Tab ${e} removed from management`))}}function u(){return[...o]}function h(e){return o.find((t=>t.tabId===e))}async function f(e,t){const a=o.find((t=>t.tabId===e));if(a){const r=a.state;a.state=t,await(0,s.saveManagedTabs)(o),await(0,s.addLogEntry)({level:"info",message:`Tab state changed from ${r} to ${t}: ${a.title}`,tabId:e})}}async function b(e){try{if(e===chrome.windows.WINDOW_ID_NONE)return;console.log(`Window focus changed to: ${e}, updating tab list...`),await c(),await(0,s.addLogEntry)({level:"info",message:"Window focus changed, tab list updated",data:{windowId:e,managedTabsCount:o.length}})}catch(t){console.error("Failed to handle window focus change:",t),await(0,s.addLogEntry)({level:"error",message:`Failed to handle window focus change: ${t}`,data:{windowId:e}})}}function w(e){if(!e)return console.log("❌ isResumeUrl: URL is empty or undefined"),!1;const t=e.startsWith("https://"),a=e.startsWith("http://"),r=e.includes("hh.kz/resume/"),s=e.includes("hh.ru/resume/"),o=(r||s)&&(t||a);return(e.includes("hh.kz")||e.includes("hh.ru"))&&(console.log(`🔍 isResumeUrl check for: ${e}`),console.log(`  - HTTPS: ${t}, HTTP: ${a}`),console.log(`  - HH.KZ resume: ${r}, HH.RU resume: ${s}`),console.log(`  - Result: ${o}`)),o}function p(){return{isInitialized:n,managedTabsCount:o.length,managedTabs:[...o]}}}},t={};function a(r){var s=t[r];if(void 0!==s)return s.exports;var o=t[r]={exports:{}};return e[r](o,o.exports,a),o.exports}a.d=(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r=a(167),s=a(658);const o=new class{constructor(){this.callbacks=new Map,this.timers=new Map,this.processingTimers=new Set,this.keepAliveAlarmName="keep_alive_alarm",chrome.alarms.onAlarm.addListener((e=>{this.handleAlarmExpiration(e)})),console.log("PersistentAlarmManager initialized"),this.initialize()}async initialize(){try{console.log("🔄 Initializing PersistentAlarmManager..."),await this.restoreState(),await this.syncChromeAlarms(),this.startHealthCheck(),this.startKeepAlive(),console.log("✅ PersistentAlarmManager initialized successfully"),await this.logEvent("info","PersistentAlarmManager initialized",{})}catch(e){console.error("❌ Failed to initialize PersistentAlarmManager:",e),await this.logEvent("error","Failed to initialize PersistentAlarmManager",{error:e instanceof Error?e.message:"Unknown error"})}}async restoreState(){try{const e=(await chrome.storage.local.get("persistent_timers")).persistent_timers||{};console.log("📥 Restoring timer state:",Object.keys(e).length,"timers");for(const[t,a]of Object.entries(e)){const e=parseInt(t,10),r=a,s=Date.now();r.isActive&&r.expirationTime>s?(this.timers.set(e,r),console.log(`✅ Restored timer for tab ${e}, expires in ${Math.round((r.expirationTime-s)/1e3)}s`)):r.isActive&&r.expirationTime<=s&&(console.log(`⏰ Timer for tab ${e} expired while offline, triggering now`),await this.handleTimerExpiration(e))}await this.logEvent("info","Timer state restored",{restoredCount:this.timers.size})}catch(e){console.error("❌ Failed to restore state:",e),await this.logEvent("error","Failed to restore state",{error:e instanceof Error?e.message:"Unknown error"})}}async syncChromeAlarms(){try{const e=(await chrome.alarms.getAll()).filter((e=>e.name.startsWith("tab_")&&e.name.endsWith("_timer")));console.log("🔄 Syncing with Chrome alarms:",e.length,"found");for(const t of e){const e=t.name.match(/^tab_(\d+)_timer$/);if(e){const a=parseInt(e[1]||"0",10);this.timers.has(a)||(console.log(`🧹 Cleaning up orphaned alarm: ${t.name}`),await chrome.alarms.clear(t.name))}}for(const[t,a]of this.timers.entries())if(a.isActive&&a.alarmName.includes("timer")&&!e.some((e=>e.name===a.alarmName))){console.log(`🔧 Recreating missing alarm for tab ${t}`);const e=Math.max(0,a.expirationTime-Date.now());e>0?await this.createChromeAlarm(a.alarmName,e):await this.handleTimerExpiration(t)}await this.logEvent("info","Chrome alarms synced",{chromeAlarms:e.length,internalTimers:this.timers.size})}catch(e){console.error("❌ Failed to sync Chrome alarms:",e),await this.logEvent("error","Failed to sync Chrome alarms",{error:e instanceof Error?e.message:"Unknown error"})}}startHealthCheck(){this.healthCheckInterval=setInterval((()=>{this.performHealthCheck()}),3e5),console.log("💓 Health check system started")}async startKeepAlive(){try{await chrome.alarms.create(this.keepAliveAlarmName,{delayInMinutes:1,periodInMinutes:1}),console.log("🔄 Keep-alive mechanism started (1-minute heartbeat)"),await this.logEvent("info","Keep-alive mechanism started",{})}catch(e){console.error("❌ Failed to start keep-alive mechanism:",e),await this.logEvent("error","Failed to start keep-alive mechanism",{error:e instanceof Error?e.message:"Unknown error"})}}async performHealthCheck(){try{console.log("💓 Performing health check...");const e=Date.now();let t=0,a=0;for(const[r,s]of this.timers.entries())s.isActive&&(a++,s.expirationTime<=e&&(console.log(`⏰ Health check found expired timer for tab ${r}`),await this.handleTimerExpiration(r),t++));await this.syncChromeAlarms(),await this.saveState(),console.log(`💓 Health check completed: ${a} active, ${t} expired`),await this.logEvent("info","Health check completed",{activeTimers:a,expiredTimers:t})}catch(e){console.error("❌ Health check failed:",e),await this.logEvent("error","Health check failed",{error:e instanceof Error?e.message:"Unknown error"})}}async saveState(){try{const e={};for(const[t,a]of this.timers.entries())e[t.toString()]=a;await chrome.storage.local.set({persistent_timers:e}),console.log("💾 Timer state saved:",Object.keys(e).length,"timers")}catch(e){console.error("❌ Failed to save state:",e),await this.logEvent("error","Failed to save state",{error:e instanceof Error?e.message:"Unknown error"})}}async createChromeAlarm(e,t){try{const a=Math.max(1,t/6e4);return await chrome.alarms.create(e,{delayInMinutes:a}),await chrome.alarms.get(e)?(console.log(`✅ Chrome alarm created: ${e} (${a} min, original: ${t}ms)`),!0):(console.error(`❌ Chrome alarm creation failed: ${e}`),!1)}catch(t){return console.error(`❌ Failed to create Chrome alarm ${e}:`,t),!1}}async startTimer(e,t=9e5){try{console.log(`🚀 Starting persistent timer for tab ${e} with interval ${t}ms (${t/1e3/60} minutes)`),await this.stopTimer(e);const a=`tab_${e}_timer`,r=Date.now(),s=r+t,o=this.timers.get(e),n={tabId:e,intervalMs:t,startTime:r,expirationTime:s,isActive:!0,alarmName:a,retryCount:o?.retryCount||0};this.timers.set(e,n);const i=await this.createChromeAlarm(a,t);if(!i)return console.error(`❌ Failed to create Chrome alarm for tab ${e}, timer will not work`),n.isActive=!1,this.timers.delete(e),void await this.logEvent("error",`Failed to create alarm for tab ${e}`,{tabId:e,intervalMs:t});await this.saveState(),console.log(`✅ Persistent timer started for tab ${e}:`,{alarmName:a,intervalMinutes:t/1e3/60,expirationTime:new Date(s).toLocaleTimeString(),alarmCreated:i,isRestart:!!o}),await this.logEvent("info",`Persistent timer started for tab ${e}`,{tabId:e,intervalMs:t,alarmName:a,alarmCreated:i,isRestart:!!o})}catch(t){console.error(`❌ Failed to start persistent timer for tab ${e}:`,t),await this.logEvent("error",`Failed to start persistent timer for tab ${e}`,{tabId:e,error:t instanceof Error?t.message:"Unknown error"})}}async stopTimer(e){try{const t=this.timers.get(e);t&&(t.alarmName&&t.alarmName.includes("timer")&&(await chrome.alarms.clear(t.alarmName),console.log(`🗑️ Alarm cleared: ${t.alarmName}`)),this.timers.delete(e),await this.saveState(),console.log(`⏹️ Persistent timer stopped for tab ${e}`),await this.logEvent("info",`Persistent timer stopped for tab ${e}`,{tabId:e}))}catch(t){console.error(`❌ Failed to stop persistent timer for tab ${e}:`,t),await this.logEvent("error",`Failed to stop persistent timer for tab ${e}`,{tabId:e,error:t instanceof Error?t.message:"Unknown error"})}}async handleTimerExpiration(e){const t=Date.now();if(this.processingTimers.has(e))console.warn(`⚠️ Timer for tab ${e} is already being processed, skipping duplicate`);else{this.processingTimers.add(e);try{console.log(`⏰ [${(new Date).toLocaleTimeString()}] Persistent timer expired for tab ${e} - STARTING PROCESSING`);const a=this.timers.get(e);if(!a)return void console.warn(`⚠️ No timer found for expired tab ${e}`);const r=Array.from(this.timers.values()).filter((e=>e.isActive));console.log(`📊 Processing tab ${e} - Active timers: ${r.length}, Total timers: ${this.timers.size}`),console.log(`📊 Active timer tabs: [${r.map((e=>e.tabId)).join(", ")}]`),console.log(`📊 Currently processing tabs: [${Array.from(this.processingTimers).join(", ")}]`);const s=Date.now(),o=a.expirationTime-s;if(o>3e4)return console.log(`⏰ Timer for tab ${e} fired early, ${Math.round(o/1e3)}s remaining. Rescheduling...`),void await this.createChromeAlarm(a.alarmName,o);a.isActive=!1;const n=this.callbacks.get(e)||this.globalCallback;if(!n)return console.warn(`⚠️ No callback registered for tab ${e}, removing timer`),this.timers.delete(e),void await this.saveState();try{console.log(`🔔 Executing persistent timer callback for tab ${e}`),await n(e),console.log(`✅ Persistent timer callback completed for tab ${e}`),a.retryCount=0}catch(t){if(console.error(`❌ Persistent timer callback failed for tab ${e}:`,t),a.retryCount=(a.retryCount||0)+1,a.lastError=t instanceof Error?t.message:"Unknown callback error",await this.logEvent("error",`Persistent timer callback failed for tab ${e}`,{tabId:e,retryCount:a.retryCount,error:a.lastError}),a.retryCount<5){const t=[1,2,5,10,15][a.retryCount-1]||15,r=60*t*1e3;console.log(`🔄 Scheduling retry ${a.retryCount}/5 for tab ${e} in ${t} minutes`),a.expirationTime=s+r,a.isActive=!0;try{return await this.createChromeAlarm(a.alarmName,r),await this.saveState(),void console.log(`✅ Retry timer scheduled for tab ${e}`)}catch(t){console.error(`❌ Failed to schedule retry for tab ${e}:`,t)}}console.warn(`⚠️ Max retries exceeded or retry failed for tab ${e}, using fallback timer`),a.retryCount=0,a.expirationTime=s+18e5,a.isActive=!0;try{return await this.createChromeAlarm(a.alarmName,18e5),await this.saveState(),void console.log(`✅ Fallback timer set for tab ${e} (30 minutes)`)}catch(t){return console.error(`❌ Even fallback timer failed for tab ${e}:`,t),this.timers.delete(e),void await this.saveState()}}await this.saveState();const i=Date.now()-t;console.log(`✅ [${(new Date).toLocaleTimeString()}] Timer processing COMPLETED for tab ${e} in ${i}ms`),await this.logEvent("info",`Persistent timer expired for tab ${e}`,{tabId:e,retryCount:a.retryCount,processingTimeMs:i})}catch(t){console.error(`❌ Failed to handle persistent timer expiration for tab ${e}:`,t),await this.logEvent("error",`Failed to handle persistent timer expiration for tab ${e}`,{tabId:e,error:t instanceof Error?t.message:"Unknown error"});try{const t=this.timers.get(e);t&&(console.log(`🚨 Emergency timer restart for tab ${e} after critical error in handleTimerExpiration`),t.expirationTime=Date.now()+9e5,t.isActive=!0,t.retryCount=Math.min((t.retryCount||0)+1,3),await this.createChromeAlarm(t.alarmName,9e5),await this.saveState(),console.log(`✅ Emergency timer set for tab ${e} (15 minutes)`))}catch(t){console.error(`❌ Emergency timer restart failed for tab ${e}:`,t)}}finally{this.processingTimers.delete(e),console.log(`🔓 Released processing lock for tab ${e}`)}}}async handleAlarmExpiration(e){try{if(console.log(`🔔 Chrome alarm fired: ${e.name} at ${(new Date).toLocaleTimeString()}`),e.name===this.keepAliveAlarmName)return console.log("💓 Keep-alive heartbeat"),void await this.logEvent("info","Keep-alive heartbeat",{activeTimers:this.timers.size});const t=e.name.match(/^tab_(\d+)_timer$/);if(!t)return void console.warn(`⚠️ Unknown alarm format: ${e.name}`);const a=parseInt(t[1]||"0",10);this.handleTimerExpiration(a).catch((e=>{console.error(`❌ Async timer expiration failed for tab ${a}:`,e)})),console.log(`🚀 Timer expiration processing started for tab ${a} (non-blocking)`)}catch(t){console.error(`❌ Failed to handle alarm expiration for ${e.name}:`,t)}}setGlobalCallback(e){this.globalCallback=e,console.log("🌐 Global callback set for persistent timers")}removeCallback(e){this.callbacks.delete(e),console.log(`🗑️ Callback removed for tab ${e}`)}getTimerStatus(e){const t=this.timers.get(e);if(!t)return{exists:!1,isActive:!1,remainingMs:0,remainingFormatted:"Timer not active"};const a=Date.now(),r=Math.max(0,t.expirationTime-a),s=Math.floor(r/6e4),o=Math.floor(r%6e4/1e3),n=0===r?"Timer not active":s>0?`${s}m ${o}s`:`${o}s`;return{exists:!0,isActive:t.isActive,remainingMs:r,remainingFormatted:n,startTime:t.startTime,intervalMs:t.intervalMs,alarmName:t.alarmName,retryCount:t.retryCount}}isTimerActive(e){const t=this.timers.get(e);return!!t&&t.isActive}getActiveTimers(){return Array.from(this.timers.values()).filter((e=>e.isActive))}async resetTimer(e,t=9e5){console.log(`🔄 Resetting persistent timer for tab ${e} with interval ${t/1e3/60} minutes`),await this.stopTimer(e),await this.startTimer(e,t)}async pauseTimer(e){try{const t=this.timers.get(e);if(!t||!t.isActive)return!1;t.alarmName&&t.alarmName.includes("timer")&&await chrome.alarms.clear(t.alarmName);const a=Math.max(0,t.expirationTime-Date.now());return t.isActive=!1,t.remainingMs=a,await this.saveState(),console.log(`⏸️ Persistent timer paused for tab ${e}, ${a}ms remaining`),!0}catch(t){return console.error(`❌ Failed to pause persistent timer for tab ${e}:`,t),!1}}async resumeTimer(e){try{const t=this.timers.get(e);if(!t||t.isActive)return t?.isActive||!1;const a=t.remainingMs||0;return a>0?(await this.startTimer(e,a),console.log(`▶️ Persistent timer resumed for tab ${e}`),!0):(await this.handleTimerExpiration(e),!0)}catch(t){return console.error(`❌ Failed to resume persistent timer for tab ${e}:`,t),!1}}async handleTabClosure(e){console.log(`🗑️ Handling tab closure for tab ${e}`),await this.stopTimer(e),this.callbacks.delete(e)}async cleanup(){try{console.log("🧹 Cleaning up all persistent timers..."),this.healthCheckInterval&&clearInterval(this.healthCheckInterval);for(const e of this.timers.values())e.alarmName&&e.alarmName.includes("timer")&&await chrome.alarms.clear(e.alarmName);await chrome.alarms.clear(this.keepAliveAlarmName),this.timers.clear(),this.callbacks.clear(),await chrome.storage.local.remove("persistent_timers"),console.log("✅ All persistent timers cleaned up"),await this.logEvent("info","All persistent timers cleaned up",{})}catch(e){console.error("❌ Failed to cleanup persistent timers:",e),await this.logEvent("error","Failed to cleanup persistent timers",{error:e instanceof Error?e.message:"Unknown error"})}}async logEvent(e,t,a){try{await(0,r.addLogEntry)({level:e,message:`PersistentAlarmManager: ${t}`,data:a})}catch(e){console.error("Failed to log persistent timer event:",e)}}};var n=a(115);console.log("HeadHunter Resume Auto-Boost Extension: Service Worker loaded");let i=!1,l=!1;const c=new Set;function d(e){if(!e)return!1;const t=e.startsWith("https://"),a=e.startsWith("http://"),r=e.includes("hh.kz/resume/"),s=e.includes("hh.ru/resume/");return(r||s)&&(t||a)}const m=new class{constructor(){this.failures=new Map,this.lastFailureTime=new Map,this.maxFailures=5,this.resetTimeMs=18e5}isOpen(e){const t=this.failures.get(e)||0,a=this.lastFailureTime.get(e)||0;return t>=this.maxFailures&&(Date.now()-a<this.resetTimeMs||(this.failures.set(e,0),this.lastFailureTime.delete(e),!1))}recordFailure(e){const t=this.failures.get(e)||0;this.failures.set(e,t+1),this.lastFailureTime.set(e,Date.now()),t+1>=this.maxFailures&&console.log(`🔴 Circuit breaker OPENED for tab ${e} (${t+1} failures)`)}recordSuccess(e){const t=(this.failures.get(e)||0)>0;this.failures.set(e,0),this.lastFailureTime.delete(e),t&&console.log(`🟢 Circuit breaker reset for tab ${e}`)}getStatus(e){const t=this.failures.get(e)||0,a=this.isOpen(e),r=this.lastFailureTime.get(e),s={failures:t,isOpen:a};return a&&r&&(s.timeToReset=this.resetTimeMs-(Date.now()-r)),s}},g=new class{constructor(){this.recoveryAttempts=new Map,this.maxRecoveryAttempts=3}async attemptRecovery(e,t){const a=this.recoveryAttempts.get(e)||0;if(a>=this.maxRecoveryAttempts)return console.log(`❌ Max recovery attempts reached for tab ${e}`),!1;this.recoveryAttempts.set(e,a+1),console.log(`🔄 Recovery attempt ${a+1}/${this.maxRecoveryAttempts} for tab ${e}`);try{const s=t.message;if(s.includes("Cannot access contents of the page")||s.includes("Extension manifest must request permission")){console.log(`🔒 Permission error detected for tab ${e}, attempting reload...`);const t=await chrome.tabs.get(e);if(!t||!t.url)return await this.cleanupTab(e),!1;if(!d(t.url))return await this.cleanupTab(e),!1;if("complete"!==t.status){let t=0;for(;t<10&&(await new Promise((e=>setTimeout(e,1e3))),"complete"!==(await chrome.tabs.get(e)).status);)t++}await chrome.tabs.reload(e),await new Promise((e=>setTimeout(e,5e3)));const a=await chrome.tabs.get(e);if(!a.url||!d(a.url))return await this.cleanupTab(e),!1;await chrome.scripting.executeScript({target:{tabId:e},files:["content/resumeBooster.js"]})}else{const t=await chrome.tabs.get(e);if(!t||!t.url||!d(t.url))return await this.cleanupTab(e),!1;await chrome.scripting.executeScript({target:{tabId:e},files:["content/resumeBooster.js"]})}const n=60*(await(0,r.getSettings)()).clickInterval*1e3;return await o.startTimer(e,n),console.log(`✅ Recovery successful for tab ${e}`),await(0,r.addLogEntry)({level:"info",message:`Recovery successful for tab after ${a+1} attempts`,tabId:e}),!0}catch(t){return console.error(`❌ Recovery attempt ${a+1} failed for tab ${e}:`,t),await(0,r.addLogEntry)({level:"error",message:`Recovery attempt ${a+1} failed: ${t}`,tabId:e}),!1}}async cleanupTab(e){try{await(0,s.updateTabState)(e,n.j$.REMOVED),await o.stopTimer(e),this.recoveryAttempts.delete(e),await(0,r.addLogEntry)({level:"info",message:"Tab cleaned up during recovery",tabId:e})}catch(t){console.error(`Failed to cleanup tab ${e}:`,t)}}resetRecoveryAttempts(e){this.recoveryAttempts.delete(e),console.log(`🔄 Recovery attempts reset for tab ${e}`)}getRecoveryStatus(e){return{attempts:this.recoveryAttempts.get(e)||0,maxAttempts:this.maxRecoveryAttempts}}},u=new class{constructor(){this.debounceTimers=new Map,this.cache=new Map,this.defaultCacheTtl=3e5}debounce(e,t,a){return(...r)=>{const s=this.debounceTimers.get(e);s&&clearTimeout(s);const o=setTimeout((()=>{t(...r),this.debounceTimers.delete(e)}),a);this.debounceTimers.set(e,o)}}setCache(e,t,a=this.defaultCacheTtl){this.cache.set(e,{data:t,timestamp:Date.now(),ttl:a})}getCache(e){const t=this.cache.get(e);return t?Date.now()-t.timestamp>t.ttl?(this.cache.delete(e),null):t.data:null}cleanupCache(){const e=Date.now();for(const[t,a]of this.cache.entries())e-a.timestamp>a.ttl&&this.cache.delete(t)}getMetrics(){return{activeDebouncers:this.debounceTimers.size,cacheSize:this.cache.size}}},h=new class{constructor(){this.batches=new Map,this.batchDelay=1e3,this.maxBatchSize=10}addToBatch(e,t){let a=this.batches.get(e);a||(a={operations:[]},this.batches.set(e,a)),a.operations.push(t),a.timer&&clearTimeout(a.timer),a.operations.length>=this.maxBatchSize?this.processBatch(e):a.timer=setTimeout((()=>{this.processBatch(e)}),this.batchDelay)}async processBatch(e){const t=this.batches.get(e);if(!t||0===t.operations.length)return;console.log(`📦 Processing batch ${e} with ${t.operations.length} operations`),t.timer&&clearTimeout(t.timer);const a=t.operations.splice(0);this.batches.delete(e);try{await Promise.allSettled(a.map((e=>e()))),console.log(`✅ Batch ${e} processed successfully`)}catch(t){console.error(`❌ Error processing batch ${e}:`,t)}}getMetrics(){let e=0;for(const t of this.batches.values())e+=t.operations.length;return{activeBatches:this.batches.size,totalPendingOperations:e}}},f=new class{constructor(){this.testResults=new Map,this.isTestingMode=!1}enableTestingMode(){this.isTestingMode=!0,console.log("🧪 Testing mode enabled")}disableTestingMode(){this.isTestingMode=!1,console.log("🧪 Testing mode disabled")}async runTest(e,t){if(!this.isTestingMode)return!0;console.log(`🧪 Running test: ${e}`);const a=Date.now();try{const r=await t(),s=Date.now()-a;return this.recordTestResult(e,r),r?console.log(`✅ Test passed: ${e} (${s}ms)`):console.log(`❌ Test failed: ${e} (${s}ms)`),r}catch(t){const r=Date.now()-a;return this.recordTestResult(e,!1),console.error(`💥 Test error: ${e} (${r}ms):`,t),!1}}recordTestResult(e,t){const a=this.testResults.get(e)||{passed:0,failed:0,lastRun:0};t?a.passed++:a.failed++,a.lastRun=Date.now(),this.testResults.set(e,a)}getTestResults(){const e={};for(const[t,a]of this.testResults.entries()){const r=a.passed+a.failed;e[t]={...a,successRate:r>0?a.passed/r*100:0}}return e}async runSystemTests(){console.log("🧪 Running comprehensive system tests...");const e=[{name:"Timer Management",test:()=>this.testTimerManagement()},{name:"Tab Detection",test:()=>this.testTabDetection()},{name:"Circuit Breaker",test:()=>this.testCircuitBreaker()},{name:"Error Recovery",test:()=>this.testErrorRecovery()},{name:"Performance Optimization",test:()=>this.testPerformanceOptimization()},{name:"State Persistence",test:()=>this.testStatePersistence()},{name:"Communication",test:()=>this.testCommunication()}];let t=0,a=0;const r=[];for(const{name:s,test:o}of e){const e=await this.runTest(s,o);e?t++:a++,r.push({name:s,result:e,timestamp:(new Date).toISOString()})}return console.log(`🧪 System tests completed: ${t} passed, ${a} failed`),{passed:t,failed:a,details:r}}async testTimerManagement(){try{const e=99999,t=5e3;return await o.startTimer(e,t),o.getTimerStatus(e).isActive?(await o.stopTimer(e),!o.getTimerStatus(e).isActive||(console.error("Timer stopping failed"),!1)):(console.error("Timer creation failed"),!1)}catch(e){return console.error("Timer management test failed:",e),!1}}async testTabDetection(){try{const e=["https://hh.kz/resume/12345","https://hh.ru/resume/67890","http://hh.kz/resume/test"],t=["https://google.com","https://hh.kz/vacancy/123","https://hh.ru/search",""];for(const t of e)if(!d(t))return console.error(`Valid URL incorrectly rejected: ${t}`),!1;for(const e of t)if(d(e))return console.error(`Invalid URL incorrectly accepted: ${e}`),!1;return!0}catch(e){return console.error("Tab detection test failed:",e),!1}}async testCircuitBreaker(){try{const e=99998;if(m.isOpen(e))return console.error("Circuit breaker should be closed initially"),!1;for(let t=0;t<6;t++)m.recordFailure(e);return m.isOpen(e)?(m.recordSuccess(e),!m.isOpen(e)||(console.error("Circuit breaker should be closed after success"),!1)):(console.error("Circuit breaker should be open after 6 failures"),!1)}catch(e){return console.error("Circuit breaker test failed:",e),!1}}async testErrorRecovery(){try{const e=99997;return 0!==g.getRecoveryStatus(e).attempts?(console.error("Recovery attempts should be 0 initially"),!1):(g.resetRecoveryAttempts(e),0===g.getRecoveryStatus(e).attempts||(console.error("Recovery attempts should be 0 after reset"),!1))}catch(e){return console.error("Error recovery test failed:",e),!1}}async testPerformanceOptimization(){try{const e="test_cache_key",t={test:"data",timestamp:Date.now()};u.setCache(e,t,1e3);const a=u.getCache(e);if(!a||a.test!==t.test)return console.error("Cache set/get failed"),!1;if(await new Promise((e=>setTimeout(e,1100))),null!==u.getCache(e))return console.error("Cache expiration failed"),!1;const r=u.getMetrics();return"number"==typeof r.cacheSize&&"number"==typeof r.activeDebouncers||(console.error("Performance metrics invalid"),!1)}catch(e){return console.error("Performance optimization test failed:",e),!1}}async testStatePersistence(){try{const e=await(0,r.getSettings)();if(!e||"number"!=typeof e.clickInterval)return console.error("Settings loading failed"),!1;const t=(0,s.getManagedTabsSync)();return!!Array.isArray(t)||(console.error("Managed tabs sync failed"),!1)}catch(e){return console.error("State persistence test failed:",e),!1}}async testCommunication(){try{return chrome.runtime.onMessage.hasListeners()?"number"==typeof h.getMetrics().activeBatches||(console.error("Batch operations metrics invalid"),!1):(console.error("No message listeners registered"),!1)}catch(e){return console.error("Communication test failed:",e),!1}}},b=u.debounce("discover_tabs",v,2e3),w=u.debounce("cleanup_cache",(()=>{u.cleanupCache(),console.log("🧹 Cache cleanup completed")}),3e5);function p(e){h.addToBatch("log_entries",(async()=>{await(0,r.addLogEntry)(e)}))}let y=null;async function T(){return y||(i?void 0:(y=(async()=>{try{console.log("Initializing HeadHunter Resume Auto-Boost Extension..."),await(0,r.initializeStorage)(),await(0,s.initializeTabManager)();const e=await(0,r.getSettings)();l=e.globalPaused,console.log("🔧 Settings loaded:",{clickInterval:e.clickInterval,globalPaused:e.globalPaused,maxTabs:e.maxTabs,loggingEnabled:e.loggingEnabled}),console.log(`🔧 Global pause state set to: ${l}`),o.setGlobalCallback($),setInterval((()=>{w()}),6e5),await v(),(chrome.runtime.getManifest().version.includes("dev")||"1.0.0"===chrome.runtime.getManifest().version)&&(console.log("🧪 Running initial system tests..."),f.enableTestingMode(),setTimeout((async()=>{try{const e=await f.runSystemTests();console.log(`🧪 Initial system tests completed: ${e.passed} passed, ${e.failed} failed`),e.failed>0&&console.warn("⚠️ Some system tests failed. Check console for details.")}catch(e){console.error("Failed to run initial system tests:",e)}}),5e3)),i=!0,await(0,r.addLogEntry)({level:"info",message:"Extension initialized successfully"}),console.log("HeadHunter Resume Auto-Boost Extension initialized successfully")}catch(e){console.error("Failed to initialize extension:",e),await(0,r.addLogEntry)({level:"error",message:`Failed to initialize extension: ${e}`})}finally{y=null}})(),y))}async function v(){try{const e="managed_tabs_discovery",t=u.getCache(e);if(t&&Array.isArray(t)&&t.length>0)console.log(`📋 Using cached tab discovery (${t.length} tabs)`);else{await(0,s.updateTabList)();const t=(0,s.getManagedTabsSync)();u.setCache(e,t,12e4)}const a=u.getCache(e),i=Array.isArray(a)?a:(0,s.getManagedTabsSync)();if(console.log(`Found ${i.length} resume tabs to manage`),l)console.log("⏸️ Extension is globally paused, not starting timers");else{const e=await(0,r.getSettings)(),t=60*e.clickInterval*1e3;for(const a of i)if(a.state===n.j$.DISCOVERED||a.state===n.j$.ACTIVE){const i=o.getTimerStatus(a.tabId);i.isActive&&i.exists||(console.log(`🚀 Starting timer for tab ${a.tabId}: ${a.title}`),await(0,s.updateTabState)(a.tabId,n.j$.ACTIVE),o.startTimer(a.tabId,t),await(0,r.addLogEntry)({level:"info",message:`Started timer for tab: ${a.title} (${e.clickInterval} min interval)`,tabId:a.tabId}))}console.log(`✅ Timer initialization completed for ${i.length} tabs`)}}catch(e){console.error("Failed to discover and manage tabs:",e),await(0,r.addLogEntry)({level:"error",message:`Failed to discover and manage tabs: ${e}`})}}async function $(e){const t=Date.now();if(c.has(e))console.warn(`⚠️ Tab ${e} already being processed, skipping`);else{c.add(e);try{if(console.log(`🎯 Timer expired for tab ${e} - processing...`),l)return;if(m.isOpen(e)){const t=m.getStatus(e);console.log(`🔴 Circuit breaker open for tab ${e} (${t.failures} failures)`),p({level:"warning",message:`Circuit breaker open, skipping tab (${t.failures} failures)`,tabId:e});const a=60*(await(0,r.getSettings)()).clickInterval*1e3;return void await o.startTimer(e,a)}const a=(0,s.getManagedTabsSync)().find((t=>t.tabId===e));if(!a)return void console.warn(`Tab ${e} not found in managed tabs`);if(a.state===n.j$.PAUSED)return;let i=!1;try{const t=await chrome.tabs.get(e);i=!!t&&!!t.url&&d(t.url)}catch(t){return console.warn(`Tab ${e} no longer exists:`,t),await(0,s.updateTabState)(e,n.j$.REMOVED),void await o.stopTimer(e)}if(!i)return console.warn(`Tab ${e} is not a valid HeadHunter resume page`),await(0,s.updateTabState)(e,n.j$.REMOVED),void await o.stopTimer(e);try{let t=!1;try{t=!!await chrome.tabs.sendMessage(e,{type:"TEST_MESSAGE"})}catch(e){}if(!t){const t=await chrome.tabs.get(e);if(!t||!t.url)throw new Error(`Tab ${e} does not exist or has no URL`);if("complete"!==t.status){let t=0;for(;t<20&&(await new Promise((e=>setTimeout(e,500))),"complete"!==(await chrome.tabs.get(e)).status);)t++}const a=await chrome.tabs.get(e);if(!a.url||!d(a.url))throw new Error(`Tab ${e} is no longer a valid resume page`);await chrome.scripting.executeScript({target:{tabId:e},files:["content/resumeBooster.js"]}),await new Promise((e=>setTimeout(e,1e3)))}try{await chrome.tabs.sendMessage(e,{type:"TEST_MESSAGE"})}catch(e){throw new Error("Content script not responding after injection")}}catch(t){console.error(`❌ Content script injection failed for tab ${e}:`,t);const a=t.message;if(a.includes("Cannot access contents of the page")||a.includes("Extension manifest must request permission")){console.log(`🔒 Permission error for tab ${e}, attempting reload...`);try{const t=await chrome.tabs.get(e);if(!t.url||!d(t.url))return await(0,s.updateTabState)(e,n.j$.REMOVED),void await o.stopTimer(e);await chrome.tabs.reload(e),await new Promise((e=>setTimeout(e,3e3))),await chrome.scripting.executeScript({target:{tabId:e},files:["content/resumeBooster.js"]})}catch(e){throw new Error(`Permission error and reload failed: ${t}`)}}else try{await chrome.scripting.executeScript({target:{tabId:e},func:()=>{window.alternativeInjectionTest=!0}})}catch(e){throw new Error(`All injection methods failed: ${t}`)}}const c={type:"BOOST_RESUME"},u=60*(await(0,r.getSettings)()).clickInterval*1e3;let f=n.j$.ACTIVE;try{const t=await async function(e,t,a=3,r=1e3){let s=null;for(let o=1;o<=a;o++)try{1!==o&&o!==a||console.log(`📤 Sending ${t.type} to tab ${e} (attempt ${o}/${a})`);const r=await chrome.tabs.get(e);if(!r||!r.url||!d(r.url))throw new Error(`Tab ${e} is no longer a valid resume tab`);const s=await chrome.tabs.sendMessage(e,t);return o>1&&console.log(`✅ Message sent successfully to tab ${e} on attempt ${o}`),s}catch(t){if(s=t,o===a&&console.warn(`❌ All attempts failed for tab ${e}:`,t),o===a)break;const n=r*Math.pow(2,o-1);await new Promise((e=>setTimeout(e,n)));try{await chrome.scripting.executeScript({target:{tabId:e},files:["content/resumeBooster.js"]})}catch(t){o===a-1&&console.log(`⚠️ Content script re-injection failed for tab ${e}`)}}throw s||new Error(`Failed to send message to tab ${e} after ${a} attempts`)}(e,c);t.success?(m.recordSuccess(e),g.resetRecoveryAttempts(e),h.addToBatch("log_entries",(async()=>{await(0,r.addLogEntry)({level:"info",message:`Successfully clicked boost button for tab: ${a.title}`,tabId:e})})),console.log(`✅ Button click successful for tab ${e}`),f=n.j$.ACTIVE):(m.recordFailure(e),await(0,r.addLogEntry)({level:"warning",message:`Failed to click boost button for tab: ${a.title}`,tabId:e}),console.log(`⚠️ Button click failed for tab ${e}`),f=n.j$.ACTIVE)}catch(t){m.recordFailure(e),console.error(`Failed to send message to tab ${e}:`,t),await g.attemptRecovery(e,t)?(console.log(`✅ Recovery successful for tab ${e}`),f=n.j$.ACTIVE):(await(0,r.addLogEntry)({level:"error",message:`Failed to communicate with tab: ${a.title}`,tabId:e}),console.log(`❌ Communication failed for tab ${e}`),f=n.j$.ACTIVE)}try{await o.startTimer(e,u),await(0,s.updateTabState)(e,f),await(0,r.addLogEntry)({level:"info",message:`Timer restarted for tab: ${a.title} (${u/1e3/60} min interval)`,tabId:e});const n=Date.now()-t;console.log(`✅ Timer restarted for tab ${e} (${n}ms)`)}catch(t){console.error(`❌ Failed to restart timer for tab ${e}:`,t),await(0,r.addLogEntry)({level:"error",message:`Failed to restart timer for tab: ${a.title}`,tabId:e}),await(0,s.updateTabState)(e,n.j$.ERROR);try{await o.startTimer(e,u),console.log(`✅ Fallback timer started for tab ${e}`)}catch(t){console.error(`❌ Fallback timer failed for tab ${e}:`,t)}}}catch(t){if(m.recordFailure(e),console.error(`Error handling timer expiration for tab ${e}:`,t),!await g.attemptRecovery(e,t)){await(0,r.addLogEntry)({level:"error",message:`Critical error handling timer expiration for tab ${e}: ${t}`,tabId:e});try{const t=60*(await(0,r.getSettings)()).clickInterval*1e3;await o.startTimer(e,t),await(0,s.updateTabState)(e,n.j$.ACTIVE),console.log(`✅ Emergency timer started for tab ${e}`)}catch(t){console.error(`❌ Emergency timer failed for tab ${e}:`,t)}}}finally{c.delete(e)}}}async function E(e,t,a){try{const i=(0,s.getManagedTabsSync)().find((t=>t.tabId===e));if(!i)return void a({success:!1,error:"Tab not found"});if(t)await o.pauseTimer(e),await(0,s.updateTabState)(e,n.j$.PAUSED),await(0,r.addLogEntry)({level:"info",message:`Tab paused: ${i.title}`,tabId:e});else{const t=60*(await(0,r.getSettings)()).clickInterval*1e3;await(0,s.updateTabState)(e,n.j$.ACTIVE),await o.startTimer(e,t),await(0,r.addLogEntry)({level:"info",message:`Tab resumed: ${i.title}`,tabId:e})}a({success:!0})}catch(e){console.error("Failed to set tab pause:",e),a({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}chrome.runtime.onMessage.addListener(((e,t,c)=>{switch(["GET_EXTENSION_STATE"].includes(e.type)||console.log("Service worker received message:",e.type,"from:",t.tab?.id||"popup"),e.type){case"GET_EXTENSION_STATE":return async function(e){try{const t=await(0,r.getSettings)(),a=(0,s.getManagedTabsSync)().map((e=>{const t=o.getTimerStatus(e.tabId),a=m.getStatus(e.tabId),r=g.getRecoveryStatus(e.tabId);return{...e,timerStatus:t,circuitBreakerStatus:a,recoveryStatus:r}}));e({success:!0,data:{isInitialized:i,globalPaused:l,settings:t,managedTabs:a,activeTimers:o.getActiveTimers().length,performanceMetrics:{optimizer:u.getMetrics(),batchOperations:h.getMetrics()},testResults:f.getTestResults()}})}catch(t){console.error("❌ Failed to get extension state:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;case"SET_GLOBAL_PAUSE":case"GLOBAL_PAUSE_TOGGLE":return async function(e,t){try{if(console.log(`🔄 Setting global pause to: ${e}`),l=e,await Promise.resolve().then(a.bind(a,167)).then((t=>t.saveGlobalPauseState(e))),e){const e=(0,s.getManagedTabsSync)();console.log(`⏸️ Pausing ${e.length} tabs`);for(const t of e)t.state===n.j$.ACTIVE&&(await o.pauseTimer(t.tabId),await(0,s.updateTabState)(t.tabId,n.j$.PAUSED),console.log(`⏸️ Paused tab ${t.tabId}: ${t.title}`));await(0,r.addLogEntry)({level:"info",message:"Extension globally paused"})}else{const e=(0,s.getManagedTabsSync)(),t=await(0,r.getSettings)(),a=60*t.clickInterval*1e3;console.log(`▶️ Resuming ${e.length} tabs with ${t.clickInterval}min interval`);for(const t of e)t.state===n.j$.PAUSED&&(await(0,s.updateTabState)(t.tabId,n.j$.ACTIVE),await o.startTimer(t.tabId,a),console.log(`▶️ Resumed tab ${t.tabId}: ${t.title}`));await(0,r.addLogEntry)({level:"info",message:"Extension globally resumed"})}console.log(`✅ Global pause set to: ${e}`),t({success:!0})}catch(e){console.error("❌ Failed to set global pause:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}(e.paused,c),!0;case"SET_TAB_PAUSE":return E(e.tabId,e.paused,c),!0;case"TAB_PAUSE_TOGGLE":return async function(e,t){try{if(!e)return void t({success:!1,error:"Tab ID is required"});const a=(0,s.getManagedTabsSync)().find((t=>t.tabId===e));if(!a)return void t({success:!1,error:"Tab not found"});const r=a.state!==n.j$.PAUSED;await E(e,r,t)}catch(e){console.error("Failed to toggle tab pause:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}(e.tabId,c),!0;case"SET_INTERVAL":case"SETTINGS_UPDATE":return"SETTINGS_UPDATE"===e.type&&e.data?async function(e,t){try{if(console.log("Handling settings update:",e),await Promise.resolve().then(a.bind(a,167)).then((t=>t.saveSettings(e))),e.clickInterval){const t=(0,s.getManagedTabsSync)(),a=60*e.clickInterval*1e3;for(const e of t)e.state===n.j$.ACTIVE&&o.isTimerActive(e.tabId)&&await o.resetTimer(e.tabId,a)}const i=(0,s.getManagedTabsSync)();console.log(`🔄 Notifying ${i.length} content scripts about settings update`);for(const t of i)try{console.log(`🔄 Sending SETTINGS_UPDATE to tab ${t.tabId} (${t.title})`),await chrome.tabs.sendMessage(t.tabId,{type:"SETTINGS_UPDATE",data:e}),console.log(`✅ Settings update sent to tab ${t.tabId} with refreshInterval: ${e.refreshInterval}`)}catch(e){console.log(`❌ Failed to notify tab ${t.tabId} about settings update:`,e)}await(0,r.addLogEntry)({level:"info",message:`Settings updated: ${Object.keys(e).join(", ")} - Click interval: ${e.clickInterval}min, Refresh interval: ${e.refreshInterval}min`}),t({success:!0})}catch(e){console.error("Failed to update settings:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}(e.data,c):async function(e,t){try{await Promise.resolve().then(a.bind(a,167)).then((t=>t.saveInterval(e)));const i=(0,s.getManagedTabsSync)(),l=60*e*1e3;for(const e of i)e.state===n.j$.ACTIVE&&o.isTimerActive(e.tabId)&&await o.resetTimer(e.tabId,l);await(0,r.addLogEntry)({level:"info",message:`Interval updated to ${e} minutes`}),t({success:!0})}catch(e){console.error("Failed to set interval:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}(e.interval,c),!0;case"REFRESH_TABS":return async function(e){try{console.log("🔄 Refreshing tabs..."),u.setCache("managed_tabs_discovery",[],0),await(0,s.updateTabList)(),await v();const t=(0,s.getManagedTabsSync)();console.log(`✅ Refresh completed: found ${t.length} tabs`),e({success:!0,message:`Tabs refreshed successfully - found ${t.length} resume tabs`,data:{managedTabsCount:t.length}})}catch(t){console.error("Failed to refresh tabs:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;case"TAB_REMOVE":return async function(e,t){try{if(!e)return void t({success:!1,error:"Tab ID is required"});const n=(0,s.getManagedTabsSync)().find((t=>t.tabId===e));if(!n)return void t({success:!1,error:"Tab not found"});o.stopTimer(e),o.removeCallback(e),await Promise.resolve().then(a.bind(a,658)).then((t=>t.removeTab(e))),await(0,r.addLogEntry)({level:"info",message:`Tab manually removed from management: ${n.title}`,tabId:e}),console.log(`Tab ${e} removed from management: ${n.title}`),t({success:!0})}catch(e){console.error("Failed to remove tab:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}(e.tabId,c),!0;case"RUN_SYSTEM_TESTS":return async function(e){try{console.log("🧪 Running system tests requested from popup"),f.enableTestingMode();const t=await f.runSystemTests();p({level:"info",message:`System tests completed: ${t.passed} passed, ${t.failed} failed`}),e({success:!0,data:t})}catch(t){console.error("Failed to run system tests:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;case"ENABLE_TESTING_MODE":return async function(e){try{f.enableTestingMode(),p({level:"info",message:"Testing mode enabled"}),e({success:!0})}catch(t){console.error("Failed to enable testing mode:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;case"DISABLE_TESTING_MODE":return async function(e){try{f.disableTestingMode(),p({level:"info",message:"Testing mode disabled"}),e({success:!0})}catch(t){console.error("Failed to disable testing mode:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;case"GET_TEST_RESULTS":return async function(e){try{e({success:!0,data:f.getTestResults()})}catch(t){console.error("Failed to get test results:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;case"FORCE_START_TIMER":return async function(e,t){try{const a=(0,s.getManagedTabsSync)().find((t=>t.tabId===e));if(!a)return void t({success:!1,error:"Tab not found"});if(a.state===n.j$.ACTIVE)return void t({success:!0,message:"Tab is already active"});await(0,s.updateTabState)(e,n.j$.ACTIVE);const i=60*(await(0,r.getSettings)()).refreshInterval*1e3;o.startTimer(e,i),await(0,r.addLogEntry)({level:"info",message:`Timer manually started for tab: ${a.title}`,tabId:e}),t({success:!0,message:`Timer started for tab ${e}`})}catch(e){console.error("Failed to force start timer:",e),t({success:!1,error:e instanceof Error?e.message:"Unknown error"})}}(e.tabId,c),!0;case"GET_LOGS":return async function(e){try{e({success:!0,data:((await chrome.storage.local.get(["log_entries"])).log_entries||[]).slice(-50)})}catch(t){console.error("Failed to get logs:",t),e({success:!1,error:t instanceof Error?t.message:"Unknown error"})}}(c),!0;default:return console.warn("Unknown message type:",e.type),c({success:!1,error:"Unknown message type"}),!1}})),chrome.runtime.onInstalled.addListener((async e=>{console.log("Extension installed/updated:",e),await(0,r.addLogEntry)({level:"info",message:`Extension ${e.reason}: version ${chrome.runtime.getManifest().version}`}),await T()})),chrome.runtime.onStartup.addListener((async()=>{console.log("Extension startup"),await(0,r.addLogEntry)({level:"info",message:"Extension started"}),await T()})),chrome.tabs.onUpdated.addListener((async(e,t,a)=>{if(i&&"complete"===t.status){b();try{const t=await chrome.tabs.get(e);t&&t.url&&d(t.url)&&setTimeout((async()=>{const t=(0,s.getManagedTabsSync)().find((t=>t.tabId===e));if(t&&t.state===n.j$.DISCOVERED&&!l){const a=60*(await(0,r.getSettings)()).clickInterval*1e3;await(0,s.updateTabState)(e,n.j$.ACTIVE),o.startTimer(e,a),p({level:"info",message:`New resume tab detected and timer started: ${t.title}`,tabId:e})}}),3e3)}catch(t){console.log(`Could not check tab ${e}:`,t)}}})),chrome.tabs.onRemoved.addListener((async e=>{i&&(o.handleTabClosure(e),await(0,r.addLogEntry)({level:"info",message:"Tab closed and timer cleaned up",tabId:e}))})),T()})();