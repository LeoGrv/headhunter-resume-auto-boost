  if (method.name === 'pointer_events') {
    // üéØ Method 1: POINTER EVENTS API (—Å–∞–º—ã–π —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π)
    try {
      const rect = button.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // Pointer Events –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å
      const pointerDown = new PointerEvent('pointerdown', {
        bubbles: true,
        cancelable: true,
        view: window,
        pointerId: 1,
        pointerType: 'mouse',
        clientX: centerX,
        clientY: centerY,
        pressure: 0.8,
        button: 0,
        buttons: 1
      });
      button.dispatchEvent(pointerDown);
      
      await new Promise(resolve => setTimeout(resolve, 80 + Math.random() * 120));
      
      const pointerUp = new PointerEvent('pointerup', {
        bubbles: true,
        cancelable: true,
        view: window,
        pointerId: 1,
        pointerType: 'mouse',
        clientX: centerX,
        clientY: centerY,
        pressure: 0,
        button: 0,
        buttons: 0
      });
      button.dispatchEvent(pointerUp);
      
      await new Promise(resolve => setTimeout(resolve, 20));
      button.click();
      
      clickResults.push('Pointer Events: SUCCESS');
      clickSuccess = true;
    } catch (error) {
      clickResults.push(`Pointer Events: FAILED - ${error}`);
    }
  } else if (method.name === 'touch_events') {
    // üéØ Method 2: TOUCH EVENTS (–æ–±—Ö–æ–¥ –º–æ–±–∏–ª—å–Ω–æ–π –∑–∞—â–∏—Ç—ã)
    try {
      const rect = button.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // –°–æ–∑–¥–∞–µ–º touch –æ–±—ä–µ–∫—Ç
      const touch = new Touch({
        identifier: Date.now(),
        target: button,
        clientX: centerX,
        clientY: centerY,
        radiusX: 10,
        radiusY: 10,
        rotationAngle: 0,
        force: 0.8
      });
      
      // TouchStart
      const touchStart = new TouchEvent('touchstart', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [touch],
        targetTouches: [touch],
        changedTouches: [touch]
      });
      button.dispatchEvent(touchStart);
      
      await new Promise(resolve => setTimeout(resolve, 120 + Math.random() * 180));
      
      // TouchEnd
      const touchEnd = new TouchEvent('touchend', {
        bubbles: true,
        cancelable: true,
        view: window,
        touches: [],
        targetTouches: [],
        changedTouches: [touch]
      });
      button.dispatchEvent(touchEnd);
      
      await new Promise(resolve => setTimeout(resolve, 50));
      button.click();
      
      clickResults.push('Touch Events: SUCCESS');
      clickSuccess = true;
    } catch (error) {
      clickResults.push(`Touch Events: FAILED - ${error}`);
    }
  } else if (method.name === 'raf_synchronized') {
    // üéØ Method 3: RAF SYNCHRONIZED CLICK (—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –±—Ä–∞—É–∑–µ—Ä–æ–º)
    try {
      const rafClick = () => {
        return new Promise<void>((resolve) => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              button.click();
              resolve();
            });
          });
        });
      };
      
      await rafClick();
      clickResults.push('RAF Synchronized: SUCCESS');
      clickSuccess = true;
    } catch (error) {
      clickResults.push(`RAF Synchronized: FAILED - ${error}`);
    }
  } else if (method.name === 'intersection_click') {
    // üéØ Method 4: INTERSECTION OBSERVER CLICK (–∫–ª–∏–∫ –∫–æ–≥–¥–∞ –≤–∏–¥–Ω–∞)
    try {
      const clickWhenVisible = () => {
        return new Promise<void>((resolve) => {
          const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                observer.disconnect();
                setTimeout(() => {
                  button.click();
                  resolve();
                }, 100 + Math.random() * 200);
              }
            });
          }, { threshold: [0.5, 0.75, 1.0] });
          
          observer.observe(button);
          
          // Fallback —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
          setTimeout(() => {
            observer.disconnect();
            button.click();
            resolve();
          }, 2000);
        });
      };
      
      await clickWhenVisible();
      clickResults.push('Intersection Click: SUCCESS');
      clickSuccess = true;
    } catch (error) {
      clickResults.push(`Intersection Click: FAILED - ${error}`);
    }
  } else if (method.name === 'multi_frame') {
    // üéØ Method 5: MULTI-FRAME CLICK (—Ä–∞—Å—Ç—è–Ω—É—Ç—ã–π –≤–æ –≤—Ä–µ–º–µ–Ω–∏)
    try {
      const rect = button.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // –†–∞—Å—Ç—è–≥–∏–≤–∞–µ–º –∫–ª–∏–∫ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–∞–¥—Ä–æ–≤
      const frames = [
        () => {
          const mouseDown = new MouseEvent('mousedown', {
            bubbles: true,
            cancelable: true,
            view: window,
            clientX: centerX,
            clientY: centerY,
            button: 0,
            buttons: 1
          });
          button.dispatchEvent(mouseDown);
        },
        () => {
          const mouseUp = new MouseEvent('mouseup', {
            bubbles: true,
            cancelable: true,
            view: window,
            clientX: centerX,
            clientY: centerY,
            button: 0,
            buttons: 0
          });
          button.dispatchEvent(mouseUp);
        },
        () => {
          button.click();
        }
      ];
      
      // –í—ã–ø–æ–ª–Ω—è–µ–º –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
      for (let i = 0; i < frames.length; i++) {
        await new Promise(resolve => {
          requestAnimationFrame(() => {
            frames[i]();
            resolve(undefined);
          });
        });
        
        if (i < frames.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 16 + Math.random() * 32));
        }
      }
      
      clickResults.push('Multi-Frame: SUCCESS');
      clickSuccess = true;
    } catch (error) {
      clickResults.push(`Multi-Frame: FAILED - ${error}`);
    }
  } 